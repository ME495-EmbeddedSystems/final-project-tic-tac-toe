#!/usr/bin/env python
import numpy as np
import cv2 as cv

cap = cv.VideoCapture(2)

#create a 2d array to hold the gamestate
gamestate = [["-","-","-"],["-","-","-"],["-","-","-"]]

#kernel used for noise removal
kernel =  np.ones((5,5),np.uint8)

while(1):
    # Load a color image
    _, img = cap.read()

    img_width = img.shape[0]
    img_height = img.shape[1]
    # turn into grayscale
    gray =  cv.cvtColor(img, cv.COLOR_BGR2GRAY)
    # turn into thresholded binary
    ret,thresh1 = cv.threshold(gray,127,255,cv.THRESH_BINARY)
    #thresh1 = cv.adaptiveThreshold(blurred,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,11,2)

    #blurred = cv.GaussianBlur(thresh1, (3, 3), 0)

    edges = cv.Canny(thresh1, 10, 100)

    #remove noise from binary
    #thresh1 = cv.morphologyEx(thresh1, cv.MORPH_OPEN, kernel)

    #find and draw contours. RETR_EXTERNAL retrieves only the extreme outer contours
    im2, contours, hierarchy = cv.findContours(edges.copy(), cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)
    cv.drawContours(img, contours, -1, (0,255,0), 15)


    for cnt in contours:
            #print(cv.contourArea(cnt))
            # ignore small contours that are not tiles
            if cv.contourArea(cnt) > 30:

                    # get coordinates of tile
                    x,y,w,h = cv.boundingRect(cnt)

                    # create new image from binary, for further analysis. Trim off the edge that has a line
                    tile = edges[x+40:x+w-80,y+40:y+h-80]
                    # create new image from main image, so we can draw the contours easily
                    imgTile = img[x+40:x+w-80,y+40:y+h-80]

                    #determine the array indexes of the tile
                    tileX = int(round((float(x)/float(img_width))*3))
                    tileY = int(round((float(y)/float(img_height))*3))

                    # find contours in the tile image. RETR_TREE retrieves all of the contours and reconstructs a full hierarchy of nested contours.
                    _, c, hierarchy = cv.findContours(tile, cv.RETR_TREE , cv.CHAIN_APPROX_SIMPLE)
                    for ct in c:
                            # to prevent the tile finding itself as contour
                            if cv.contourArea(ct) < 18:
                                    cv.drawContours(imgTile, [ct], -1, (255,0,0), 15)
                                    #calculate the solitity
                                    area = cv.contourArea(ct)
                                    hull = cv.convexHull(ct)
                                    hull_area = cv.contourArea(hull)
                                    try:
                                        solidity = float(area)/hull_area
                                    except ZeroDivisionError:
                                        solidity = -100

                                    # fill the gamestate with the right sign
                                    if(solidity > 0.5):
                                            gamestate[tileX][tileY] = "O"
                                    elif(solidity < 0):
                                            gamestate[tileX][tileY] = "-"
                                    else:
                                            gamestate[tileX][tileY] = "X"

    #print the gamestate
    for line in gamestate:
            linetxt = ""
            for cel in line:
                    linetxt = linetxt + cel
            #print(linetxt)

    # resize final image
    res = cv.resize(img, None,fx=1, fy=1, interpolation = cv.INTER_CUBIC)

    # display image
    cv.imshow('image1', res)
    if cv.waitKey(1) & 0xFF == ord('q'):
      break

cap.release()
cv.destroyAllWindows()
