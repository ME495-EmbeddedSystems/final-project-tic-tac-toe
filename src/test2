#!/usr/bin/env python
import numpy as np
import cv2 as cv

#cap = cv.VideoCapture(2)

#create a 2d array to hold the gamestate
gamestate = [0,0,0,0,0,0,0,0,0]


# Load a grayscale image
img = cv.imread('x5_g15.png', cv.IMREAD_GRAYSCALE)
# Crop top of image
img_crop = img[0:150, 0:900]


# Define range of green color in grayscale
lower_green = 40
upper_green = 55

# Threshold image to get only green colors
mask = cv.inRange(img_crop, lower_green, upper_green)

# Find contours of edges
edged = cv.Canny(mask, 30, 200)

im, contours, hierarchy = cv.findContours(edged, cv.RETR_EXTERNAL,cv.CHAIN_APPROX_NONE)

# Find largest contour (the green tape)
large_cnt_index = 0
largest_peri = 0
for i in range(len(contours)):
    perimeter = cv.arcLength(contours[i],True)
    if perimeter > largest_peri:
        largest_peri = perimeter
        large_cnt_index = i

# get coordinates of tile
x,y,w,h = cv.boundingRect(contours[large_cnt_index])

# Origin adjustments
x -= 3
y -= 3
w += 6
h += 6

# measure 1 cm in pixels
cm = (w+h)/4

buffer = cm/2

tape_crop = img[y:y+h, x:x+w]

# Crop frame for each board space
top_left = img[y + 2*cm: y + 10*cm - buffer,  x + 2*cm: x + 10*cm - buffer]
top_mid = img[y+2*cm: y + 9*cm,  x + 12*cm + buffer: x + 20*cm - buffer]
top_right = img[y+2*cm: y + 10*cm - 2*buffer,  x + 22*cm + buffer: x + 30*cm ]
mid_left = img[y + 11*cm + 2*buffer: y + 20*cm - buffer,  x + 2*cm: x + 10*cm - buffer]
mid_mid = img[y+11*cm + buffer: y + 19*cm - buffer,  x + 12*cm + buffer: x + 20*cm - buffer]
mid_right = img[y+11*cm + 2*buffer: y + 19*cm - buffer,  x + 23*cm: x + 31*cm]
bot_left = img[y + 21*cm + buffer: y + 31*cm - buffer,  x + 2*cm: x + 9*cm]
bot_mid = img[y+21*cm + buffer: y + 31*cm - buffer,  x + 12*cm + buffer: x + 20*cm - buffer]
bot_right = img[y+21*cm + 2*buffer: y + 30*cm - buffer,  x + 23*cm + buffer: x + 32*cm]

board = [top_left, top_mid, top_right, mid_left, mid_mid, mid_right, bot_left, bot_mid, bot_right]
kernel = np.ones((4,4),np.uint8)

board_index = -1

for space in board:

    board_index += 1

    # Find contours of edges
    edge = cv.Canny(space, 30, 100)

    # Dilate edges to fill in gaps
    dilation = cv.dilate(edge,kernel,iterations = 1)

    # Find contours in the board space
    im2, contours, hierarchy = cv.findContours(dilation, cv.RETR_EXTERNAL,cv.CHAIN_APPROX_NONE)

    # Find largest contour (the X or O)
    large_cnt_index = 0
    largest_peri = 0
    for i in range(len(contours)):
        perimeter = cv.arcLength(contours[i],True)
        if perimeter > largest_peri:
            largest_peri = perimeter
            large_cnt_index = i

    cv.drawContours(space, contours, large_cnt_index, (255,0,0), 3)
    print len(contours), large_cnt_index
    try:
        largest_ct = contours[large_cnt_index]
    except IndexError:
        continue


    # display image
    cv.imshow('image1', space)
    cv.waitKey(0)
    cv.destroyAllWindows()

    # Determine if the space is filled by an X or O
    if cv.contourArea(largest_ct) > 3500:
        # Calculate the solitity
        area = cv.contourArea(largest_ct)
        hull = cv.convexHull(largest_ct)
        hull_area = cv.contourArea(hull)
        try:
            solidity = float(area)/hull_area
        except ZeroDivisionError:
            solidity = -100

        # fill the gamestate with the right sign
        if(solidity > 0.5):
                gamestate[board_index] = 2
        else:
                gamestate[board_index] = 1

#print the gamestate
gamestate = np.reshape(gamestate, (3,3))
print gamestate

# resize final image
res = cv.resize(top_left, None,fx=0.25, fy=0.25, interpolation = cv.INTER_CUBIC)

# display image
#cv.imshow('image1', top_left)
#cv.waitKey(0)
#cv.destroyAllWindows()
