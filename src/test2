#!/usr/bin/env python
import numpy as np
import cv2 as cv

#cap = cv.VideoCapture(2)

#create a 2d array to hold the gamestate
gamestate = [["-","-","-"],["-","-","-"],["-","-","-"]]


# Load a color image
img = cv.imread("marked4.jpg")

img_width = img.shape[0]
img_height = img.shape[1]

# turn to HSV
hsv =  cv.cvtColor(img, cv.COLOR_BGR2HSV)

# Define range of green color in HSV
lower_green = np.array([36,0,0])
upper_green = np.array([86,255,255])

# Threshold HSV image to get only green colors
mask = cv.inRange(hsv, lower_green, upper_green)

# Blur mask
mask = cv.medianBlur(mask, 5)

#Bitwise-AND mask and original frame
res = cv.bitwise_and(img,img, mask= mask)

# Find contours of edges
edged = cv.Canny(mask, 30, 200)
im, contours, hierarchy = cv.findContours(edged, cv.RETR_EXTERNAL,cv.CHAIN_APPROX_NONE)

# Find largest contour (the green tape)
large_cnt_index = 0
largest_peri = 0
for i in range(len(contours)):
    perimeter = cv.arcLength(contours[i],True)
    if perimeter > largest_peri:
        largest_peri = perimeter
        large_cnt_index = i

# get coordinates of tile
x,y,w,h = cv.boundingRect(contours[large_cnt_index])

x += 4
y += 4
w -= 8
h -= 8

# measure 1 cm in pixels
cm = (w+h)/4

print x,y,w,h
print cm

buffer = cm/2

tape_crop = img[y:y+h, x:x+w]

top_left_crop = img[y + 2*cm + buffer: y + 2*cm + 7*cm - 2*buffer,  x + 2*cm + buffer: x + 2*cm + 7*cm - buffer]

# Find contours of edges
edge = cv.Canny(top_left_crop, 30, 200)
im2, contours, hierarchy = cv.findContours(edge, cv.RETR_EXTERNAL,cv.CHAIN_APPROX_NONE)

# Find largest contour (the X or O)
large_cnt_index = 0
largest_peri = 0
for i in range(len(contours)):
    perimeter = cv.arcLength(contours[i],True)
    if perimeter > largest_peri:
        largest_peri = perimeter
        large_cnt_index = i

cv.drawContours(top_left_crop, contours, large_cnt_index, (255,0,0), 5)
# Draw perimeter of the tape
#cv.drawContours(img, contours, large_cnt_index, (255,0,0), 5)

"""
for cnt in contours:
        #print(cv.contourArea(cnt))
        # ignore small contours that are not tiles
        if cv.contourArea(cnt) > 30:

                # get coordinates of tile
                x,y,w,h = cv.boundingRect(cnt)

                # create new image from binary, for further analysis. Trim off the edge that has a line
                tile = edges[x+40:x+w-80,y+40:y+h-80]
                # create new image from main image, so we can draw the contours easily
                imgTile = img[x+40:x+w-80,y+40:y+h-80]

                #determine the array indexes of the tile
                tileX = int(round((float(x)/float(img_width))*3))
                tileY = int(round((float(y)/float(img_height))*3))

                # find contours in the tile image. RETR_TREE retrieves all of the contours and reconstructs a full hierarchy of nested contours.
                _, c, hierarchy = cv.findContours(tile, cv.RETR_TREE , cv.CHAIN_APPROX_SIMPLE)
                for ct in c:
                        # to prevent the tile finding itself as contour
                        if cv.contourArea(ct) < 18:
                                cv.drawContours(imgTile, [ct], -1, (255,0,0), 15)
                                #calculate the solitity
                                area = cv.contourArea(ct)
                                hull = cv.convexHull(ct)
                                hull_area = cv.contourArea(hull)
                                try:
                                    solidity = float(area)/hull_area
                                except ZeroDivisionError:
                                    solidity = -100

                                # fill the gamestate with the right sign
                                if(solidity > 0.5):
                                        gamestate[tileX][tileY] = "O"
                                elif(solidity < 0):
                                        gamestate[tileX][tileY] = "-"
                                else:
                                        gamestate[tileX][tileY] = "X"

#print the gamestate
for line in gamestate:
        linetxt = ""
        for cel in line:
                linetxt = linetxt + cel
        #print(linetxt)
"""
# resize final image
res = cv.resize(top_left_crop, None,fx=0.25, fy=0.25, interpolation = cv.INTER_CUBIC)

# display image
cv.imshow('image1', top_left_crop)
cv.waitKey(0)
cv.destroyAllWindows()
