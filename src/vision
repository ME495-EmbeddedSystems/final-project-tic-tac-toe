#!/usr/bin/env python

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import cv2 as cv
import numpy as np
import argparse
from cv_bridge import CvBridge, CvBridgeError
import rospy
import intera_interface

def game_state(img_data, (edge_detection, window_name)):
    """The callback function to show image by using CvBridge and cv
       and converts image to the gamestate
    """
    #create a 2d array to hold the gamestate
    gamestate = [["-","-","-"],["-","-","-"],["-","-","-"]]

    #kernel used for noise removal
    kernel =  np.ones((7,7),np.uint8)

    bridge = CvBridge()
    try:
        cv_image = bridge.imgmsg_to_cv(img_data, "bgr8")
    except CvBridgeError, err:
        rospy.logerr(err)
        return
    # get the image width and height
    img_width = img.shape[0]
    img_height = img.shape[1]

    # turn into grayscale
    gray =  cv.cvtColor(img, cv.COLOR_BGR2GRAY)
    # turn into thresholded binary
    ret,thresh1 = cv.threshold(gray,127,255,cv.THRESH_BINARY)
    #remove noise from binary
    thresh1 = cv.morphologyEx(thresh1, cv.MORPH_OPEN, kernel)

    #find and draw contours
    im2, contours, hierarchy = cv.findContours(thresh1, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)
    cv.drawContours(img, contours, -1, (0,255,0), 15)

    tileCount = 0
    for cnt in contours:
        # ignore small contours that are not tiles
        if cv.contourArea(cnt) > 200000:
                tileCount = tileCount+1

                # get coordinates of tile
                x,y,w,h = cv.boundingRect(cnt)
                # create new image from binary, for further analysis. Trim off the edge that has a line
                tile = thresh1[x+40:x+w-80,y+40:y+h-80]
                # create new image from main image, so we can draw the contours easily
                imgTile = img[x+40:x+w-80,y+40:y+h-80]

                #determine the array indexes of the tile
                tileX = int(round((float(x)/float(img_width))*3))
                tileY = int(round((float(y)/float(img_height))*3))

                # find contours in the tile image. RETR_TREE retrieves all of the contours and reconstructs a full hierarchy of nested contours.
                im2, c, hierarchy = cv.findContours(tile, cv.RETR_TREE , cv.CHAIN_APPROX_SIMPLE)
                for ct in c:
                        # to prevent the tile finding itself as contour
                        if cv.contourArea(ct) < 180000:
                                cv.drawContours(imgTile, [ct], -1, (255,0,0), 15)
                                #calculate the solitity
                                area = cv.contourArea(ct)
                                hull = cv.convexHull(ct)
                                hull_area = cv.contourArea(hull)
                                solidity = float(area)/hull_area

                                # fill the gamestate with the right sign
                                if(solidity > 0.5):
                                        gamestate[tileX][tileY] = "O"
                                else:
                                        gamestate[tileX][tileY] = "X"

    #print the gamestate
    for line in gamestate:
        linetxt = ""
        for cel in line:
                linetxt = linetxt + "|" + cel
        print(linetxt)

    # resize final image
    res = cv.resize(img,None,fx=0.2, fy=0.2, interpolation = cv.INTER_CUBIC)

    # display image
    cv.imshow(window_name,res)
    cv.waitKey(0)
    cv.destroyAllWindows()

def main():
    """Camera Display

    Hand Camera Ranges
      - exposure: [0.01-100]
      - gain: [0-255]
    Head Camera Ranges:
      - exposure: [0-100], -1 for auto-exposure
      - gain: [0-79], -1 for auto-gain
    """
    rp = intera_interface.RobotParams()
    valid_cameras = rp.get_camera_names()
    if not valid_cameras:
        rp.log_message(("Cannot detect any camera_config"
          " parameters on this robot. Exiting."), "ERROR")
        return
    arg_fmt = argparse.RawDescriptionHelpFormatter
    parser = argparse.ArgumentParser(formatter_class=arg_fmt,
                                description=main.__doc__)
    parser.add_argument(
        '-c', '--camera', type=str, default="head_camera",
        choices=valid_cameras, help='Setup Camera Name for Camera Display')
    parser.add_argument(
        '-r', '--raw', action='store_true',
        help='Specify use of the raw image (unrectified) topic')
    parser.add_argument(
        '-e', '--edge', action='store_true',
        help='Streaming the Canny edge detection image')
    parser.add_argument(
        '-g', '--gain', type=int,
        help='Set gain for camera (-1 = auto)')
    parser.add_argument(
        '-x', '--exposure', type=float,
        help='Set exposure for camera (-1 = auto)')
    args = parser.parse_args(rospy.myargv()[1:])

    print("Initializing node... ")
    rospy.init_node('camera_display', anonymous=True)
    cameras = intera_interface.Cameras()
    if not cameras.verify_camera_exists(args.camera):
        rospy.logerr("Could not detect the specified camera, exiting the example.")
        return
    rospy.loginfo("Opening camera '{0}'...".format(args.camera))
    cameras.start_streaming(args.camera)
    rectify_image = not args.raw
    use_canny_edge = args.edge
    cameras.set_callback(args.camera, show_image_callback,
          rectify_image=rectify_image, callback_args=(use_canny_edge, args.camera))

    # optionally set gain and exposure parameters
    if args.gain is not None:
        if cameras.set_gain(args.camera, args.gain):
            rospy.loginfo("Gain set to: {0}".format(cameras.get_gain(args.camera)))

    if args.exposure is not None:
        if cameras.set_exposure(args.camera, args.exposure):
            rospy.loginfo("Exposure set to: {0}".format(cameras.get_exposure(args.camera)))

    def clean_shutdown():
        print("Shutting down camera_display node.")
        cv.destroyAllWindows()

    rospy.on_shutdown(clean_shutdown)
    rospy.loginfo("Camera_display node running. Ctrl-c to quit")
    rospy.spin()


if __name__=='__main__':
    main()
